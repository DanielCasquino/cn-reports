\section{Fourth Experience}

\subsection{ICMP and Ping}
To begin, we sent 10 ping packets to \texttt{www.ust.hk}. The output is shown
in the following picture.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1\linewidth]{img/4/ping_cmd.png}
    \caption{\texttt{www.ust.hk} ping}\label{fig:ping_cmd}
\end{figure}

Network traffic during the ping was captured with Wireshark, and we can see
that our IP is \texttt{10.100.237.128}, and the IP for the specified hostname
is \texttt{143.89.209.9}.

At first glance it seems that ICMP does not use port numbers, as seen by the
lack of a port field in the packet headers. After a brief googling session, we
concluded that ICMP does not, in fact, use ports. This protocol operates of the
network layer, and it is not in charge of sending information between
applications on different hosts.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1\linewidth]{img/4/no_port.png}
    \caption{ICMP has no port :(}\label{fig:no_port}
\end{figure}

We can also take a look at the IP datagram to see the protocol number for ICMP,
which is one, as shown in the following figure.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1\linewidth]{img/4/protocol_number.png}
    \caption{ICMP protocol number in IP datagram}\label{fig:protocol_number}
\end{figure}

Taking a closer look at \ref{fig:no_port}, we can see that the ICMP type is 8
(for echo requests, i.e. pings), and the code number is 0. The packet also has
the following fields:

\begin{itemize}
    \item \textbf{Checksum}: \texttt{0x4d4f}
    \item \textbf{Checksum status}
    \item \textbf{Identifier (BE)}: \texttt{0x0001}
    \item \textbf{Identifier (LE)}: \texttt{0x1000}
    \item \textbf{Sequence number (BE)}: \texttt{0x000c}
    \item \textbf{Sequence number (LE)}: \texttt{0x0c00}
\end{itemize}

All fields are 2 bytes, except for the checksum status, which is just a bool.

After analyzing the query packet, we took a look at the response packet, which
is shown below.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1\linewidth]{img/4/response_packet.png}
    \caption{Ping reply from \texttt{www.ust.hk}}\label{fig:response_packet}
\end{figure}

In this case, the ICMP type is 0 (ping reply), and the code number is still 0.
The rest of the packet is identical to the request packet, except for the
checksum and the additional response time field.

\subsection{ICMP and Traceroute}
Luego repetimos la captura pero esta vez con \texttt{tracert www.inria.fr} en
mi laptop con Windows~11 (conectada a la red de UTEC). La salida completa se
muestra en la Figura~\ref{fig:traceroute_cli}, donde se aprecia la progresión
hop por hop: primero los routers privados de la universidad, luego los enlaces
internacionales y finalmente la respuesta del servidor en Francia.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1\linewidth]{img/4/traceroute_cli.png}
    \caption{Resultado de \texttt{tracert www.inria.fr} en Windows}\label{fig:traceroute_cli}
\end{figure}

El archivo \texttt{printout.pcapng} confirma lo que vimos en consola: Windows
envía sondas ICMP Echo (Type~8/Code~0) con TTL 1, 2, 3, etc., y cada router en
el camino responde con un ICMP ``Time Exceeded'' (Type~11/Code~0). Cuando la
sonda llega al destino, el servidor responde con un ICMP Echo Reply
(Type~0/Code~0), lo que hace que el último salto en la captura ya no aparezca
en rojo. Esta segunda parte del laboratorio deja claro cómo \texttt{tracert}
se apoya en exactamente los mismos campos que analizamos en la sección
anterior, solo que ahora el TTL lo controla la herramienta y no el usuario.
