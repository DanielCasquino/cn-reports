\section{Fourth Experience}

\subsection{ICMP and Ping}
To begin, we sent 10 ping packets to \texttt{www.ust.hk}. The output is shown
in the following picture.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1\linewidth]{img/4/ping_cmd.png}
    \caption{\texttt{www.ust.hk} ping}\label{fig:ping_cmd}
\end{figure}

Network traffic during the ping was captured with Wireshark, and we can see
that our IP is \texttt{10.100.237.128}, and the IP for the specified hostname
is \texttt{143.89.209.9}.

At first glance it seems that ICMP does not use port numbers, as seen by the
lack of a port field in the packet headers. After a brief googling session, we
concluded that ICMP does not, in fact, use ports. This protocol operates of the
network layer, and it is not in charge of sending information between
applications on different hosts.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1\linewidth]{img/4/no_port.png}
    \caption{ICMP has no port :(}\label{fig:no_port}
\end{figure}

We can also take a look at the IP datagram to see the protocol number for ICMP,
which is one, as shown in the following figure.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1\linewidth]{img/4/protocol_number.png}
    \caption{ICMP protocol number in IP datagram}\label{fig:protocol_number}
\end{figure}

Taking a closer look at \ref{fig:no_port}, we can see that the ICMP type is 8
(for echo requests, i.e. pings), and the code number is 0. The packet also has
the following fields:

\begin{itemize}
    \item \textbf{Checksum}: \texttt{0x4d4f}
    \item \textbf{Checksum status}
    \item \textbf{Identifier (BE)}: \texttt{0x0001}
    \item \textbf{Identifier (LE)}: \texttt{0x1000}
    \item \textbf{Sequence number (BE)}: \texttt{0x000c}
    \item \textbf{Sequence number (LE)}: \texttt{0x0c00}
\end{itemize}

All fields are 2 bytes, except for the checksum status, which is just a bool.

After analyzing the query packet, we took a look at the response packet, which
is shown below.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1\linewidth]{img/4/response_packet.png}
    \caption{Ping reply from \texttt{www.ust.hk}}\label{fig:response_packet}
\end{figure}

In this case, the ICMP type is 0 (ping reply), and the code number is still 0.
The rest of the packet is identical to the request packet, except for the
checksum and the additional response time field.

\subsection{ICMP and Traceroute}
We then repeated the network capture, but this time with \texttt{tracert
    www.inria.fr} on a Windows 11 laptop, connected to UTEC's network. The output
is shown in figure~\ref{fig:traceroute_cli}, where we can see the hop by hop
progression: first, the university's private routers, then, the international
links, and finally the server's response from France.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=1\linewidth]{img/4/traceroute_cli.png}
    \caption{\texttt{tracert www.inria.fr} output}\label{fig:traceroute_cli}
\end{figure}

The \texttt{printout.pcapng} file confirms the console output: Windows sends
ICMP Echo messages (Type~8/Code~0) with TTL 1, 2, 3, etc., and each router we
reached responds with an ICMP ``Time Exceeded'' (Type~11/Code~0) packet. When
the packet reaches its destination, the server answers with an ICMP Echo Reply
(Type~0/Code~0) message, which is why the last hop doesn't show an error. This
part of the report shows how \texttt{tracert} uses the same fields we analyze
before, but the TTL is controlled by the command instead of the user.